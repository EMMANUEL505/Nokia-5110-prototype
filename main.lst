CCS PCH C Compiler, Version 4.104, 5967               12-Oct-15 17:28

               Filename: C:\Users\e882742\Documents\UTCH\Estadias\Codigo\Nokia-5110-prototype\main.lst

               ROM used: 4646 bytes (14%)
                         Largest free fragment is 28118
               RAM used: 626 (31%) at main() level
                         650 (32%) worst case
               Stack:    5 worst case (3 in main + 2 for interrupts)

*
0000:  GOTO   0A74
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  00,0E
003C:  MOVFF  01,0F
0040:  MOVFF  02,10
0044:  MOVFF  03,11
0048:  BTFSS  F9D.5
004A:  GOTO   0054
004E:  BTFSC  F9E.5
0050:  GOTO   0612
0054:  MOVFF  0E,00
0058:  MOVFF  0F,01
005C:  MOVFF  10,02
0060:  MOVFF  11,03
0064:  MOVFF  0C,FE9
0068:  MOVFF  07,FEA
006C:  BSF    07.7
006E:  MOVFF  08,FE1
0072:  MOVFF  09,FE2
0076:  MOVFF  0A,FD9
007A:  MOVFF  0B,FDA
007E:  MOVFF  12,FF3
0082:  MOVFF  13,FF4
0086:  MOVFF  14,FFA
008A:  MOVF   04,W
008C:  MOVFF  06,FE0
0090:  MOVFF  05,FD8
0094:  RETFIE 0
.................... #include "18F2550.h" 
.................... //////// Standard Header file for the PIC18F2550 device //////////////// 
.................... #device PIC18F2550 
.................... #list 
....................  
....................  
.................... //#include "16F887.h" 
.................... #USE delay(clock=8M) 
*
06FC:  MOVLW  02
06FE:  MOVWF  FEA
0700:  MOVLW  73
0702:  MOVWF  FE9
0704:  MOVF   FEF,W
0706:  BZ    0722
0708:  MOVLW  02
070A:  MOVWF  01
070C:  CLRF   00
070E:  DECFSZ 00,F
0710:  BRA    070E
0712:  DECFSZ 01,F
0714:  BRA    070C
0716:  MOVLW  97
0718:  MOVWF  00
071A:  DECFSZ 00,F
071C:  BRA    071A
071E:  DECFSZ FEF,F
0720:  BRA    0708
0722:  RETLW  00
.................... #FUSES NOMCLR, NOBROWNOUT, INTRC_IO,CPUDIV1,PLL1, NOWDT 
.................... #use rs232(baud=115200,bits=8, xmit=PIN_C6,rcv=PIN_C7, parity=N, TIMEOUT=5000) 
*
05AE:  MOVLB  2
05B0:  CLRF   x89
05B2:  MOVLW  02
05B4:  MOVWF  x88
05B6:  MOVLW  EF
05B8:  MOVWF  x87
05BA:  MOVLW  34
05BC:  MOVWF  x86
05BE:  MOVLW  11
05C0:  MOVWF  00
05C2:  DECFSZ 00,F
05C4:  BRA    05C2
05C6:  DECFSZ x86,F
05C8:  BRA    05D4
05CA:  DECFSZ x87,F
05CC:  BRA    05D4
05CE:  CLRF   17
05D0:  CLRF   01
05D2:  BRA    05E8
05D4:  BTFSS  F9E.5
05D6:  BRA    05BE
05D8:  MOVF   FAB,W
05DA:  MOVWF  17
05DC:  MOVF   FAE,W
05DE:  MOVWF  01
05E0:  BTFSS  17.1
05E2:  BRA    05E8
05E4:  BCF    FAB.4
05E6:  BSF    FAB.4
05E8:  MOVLB  0
05EA:  RETLW  00
.................... #BYTE TRISB = 0xF93 
....................  
.................... #include <PCD8544.c> 
.................... //#include <stdlib.h> 
.................... #include "PCD8544.h" 
.................... #ifndef _PIC_CCS_PCD8544_H 
.................... #define _PIC_CCS_PCD8544_H 
....................  
.................... #define BLACK 1 
.................... #define WHITE 0 
....................  
.................... #define LCDWIDTH 84 
.................... #define LCDHEIGHT 48 
....................  
.................... #define PCD8544_POWERDOWN 0x04 
.................... #define PCD8544_ENTRYMODE 0x02 
.................... #define PCD8544_EXTENDEDINSTRUCTION 0x01 
....................  
.................... #define PCD8544_DISPLAYBLANK 0x0 
.................... #define PCD8544_DISPLAYNORMAL 0x4 
.................... #define PCD8544_DISPLAYALLON 0x1 
.................... #define PCD8544_DISPLAYINVERTED 0x5 
....................  
.................... // H = 0 
.................... #define PCD8544_FUNCTIONSET 0x20 
.................... #define PCD8544_DISPLAYCONTROL 0x08 
.................... #define PCD8544_SETYADDR 0x40 
.................... #define PCD8544_SETXADDR 0x80 
....................  
.................... // H = 1 
.................... #define PCD8544_SETTEMP 0x04 
.................... #define PCD8544_SETBIAS 0x10 
.................... #define PCD8544_SETVOP 0x80 
....................  
.................... #define _RST 	PIN_B2		//S3 Reset signal for LCD	(Active in low) S3 
.................... #define _CE 	PIN_B1 		//S2 Chip enable, this signal enables the driver (active in low) 
.................... #define _DC		PIN_B0 		//S1 Data/command, 1 for data, 0 for command 
.................... #define _DIN	PIN_B4		//TX SPI data line 
.................... #define _CLK	PIN_B5 		//RX SPI clock signal 
....................  
.................... typedef unsigned int8 uint8_t; 
.................... typedef  int8 int8_t; 
.................... typedef unsigned int16 uint16_t; 
.................... typedef signed int16 int16_t; 
....................  
....................   void PCD_drawPixel(int16_t x, int16_t y, uint16_t color); 
....................   unsigned int8 PCD_getPixel(int8_t x, int8_t y); 
....................   void PCD_spiWrite(uint8_t d); 
....................  
....................   void PCD_begin(uint8_t contrast = 40, uint8_t bias = 0x04); 
....................    
....................   void PCD_command(uint8_t c); 
....................   void PCD_data(uint8_t c); 
....................    
....................   void PCD_setContrast(uint8_t val); 
....................   void PCD_clearDisplay(void); 
....................   void PCD_display(); 
....................   void PCD_drawChart(char c); 
....................   void PCD_setCursor(uint16_t x, uint16_t y);	 
....................  
.................... #include "stdlib.h" 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char *endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char *endptr); 
.................... float64 strtod(char *s,char *endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, 0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #define size_t unsigned int8 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *memmove(void *s1,char *s2,size_t n) 
.................... { 
....................    char *sc1; 
....................    char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... char *strncpy(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... char *strcat(char *s1, char *s2) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... char *strncat(char *s1, char *s2, size_t n) 
.................... { 
....................    char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,char *s2,size_t n) 
.................... { 
.................... char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:+1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(char *s1, char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(char *s1, char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1*/ 
.................... size_t strxfrm(char *s1, char *s2, size_t n) 
.................... { 
....................   char *s; 
....................   unsigned int8 n1; 
....................   n1=n; 
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    char uc; 
....................    char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... char *strchr(char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... char *strpbrk(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... char *strrchr(char *s, unsigned int8 c) 
.................... { 
....................    char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(char *s1, char *s2) 
.................... { 
....................    char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... char *strstr(char *s1, char *s2) 
.................... { 
....................    char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... char *strtok(char *s1, char *s2) 
.................... { 
....................    char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................    { 
....................       *save = ' '; 
....................       return(0); 
....................    } 
....................    end = strpbrk(beg, s2); 
....................    if (*end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................    } 
....................    save = end; 
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... char * strerror(unsigned int8 errnum) 
.................... { 
.................... char s[15]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... unsigned int8 strlen(char *s) 
.................... { 
....................    char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(char *s1, char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... char *strlwr(char *s) 
.................... { 
....................    char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... float strtof(char *s, char *endptr) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char *endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char *endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((long *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((long *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((long *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((long *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... int8 mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... uint16_t cursor_x, cursor_y; 
.................... uint8_t pcd8544_buffer[LCDWIDTH * LCDHEIGHT / 8] = { 
.................... 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x40, 0x40, 0x44, 0x44, 0x44, 0x84, 0x84, 0x08, 
.................... 0x08, 0x10, 0x20, 0xC0, 0x00, 0x00, 0x00, 0x40, 0xA0, 0xA0, 0x10, 0x10, 0x08, 0x08, 0x04, 0x04, 
.................... 0x02, 0x06, 0x08, 0x30, 0x40, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xE0, 0xF0, 0xF8, 0xFC, 0x3C, 0x1C, 0x1C, 0x1C, 
.................... 0x1C, 0x7C, 0x7C, 0x78, 0x30, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 
.................... 0x00, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0xB0, 0xF8, 0x79, 0x31, 0x01, 0x02, 0xC6, 
.................... 0x38, 0x00, 0x81, 0x42, 0x3C, 0x00, 0x00, 0xC1, 0x3E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 
.................... 0x02, 0x24, 0x34, 0x58, 0x88, 0x80, 0x00, 0x00, 0x02, 0x06, 0x09, 0x10, 0x20, 0x40, 0xC0, 0x00, 
.................... 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x3F, 0x7F, 0xFF, 0xF8, 
.................... 0xE0, 0xC0, 0xC0, 0xCE, 0xCE, 0xEE, 0xFE, 0xFE, 0xFE, 0x7E, 0x00, 0x00, 0xCF, 0xCF, 0x9D, 0x9D, 
.................... 0x99, 0xFB, 0xF3, 0x00, 0x00, 0xFF, 0xFF, 0x0F, 0x7F, 0xF8, 0xF0, 0x7F, 0x0F, 0xFF, 0xFF, 0x00, 
.................... 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04, 0x02, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x0D, 0x16, 0x14, 0x20, 0x40, 
.................... 0x43, 0x85, 0x88, 0x30, 0x40, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 
.................... 0xE0, 0xE1, 0x81, 0x01, 0x01, 0x81, 0xE0, 0xE0, 0xE0, 0x01, 0x01, 0xE0, 0xE0, 0xE1, 0x61, 0x60, 
.................... 0x60, 0x61, 0x01, 0x20, 0xE0, 0xE0, 0xC0, 0x00, 0xC0, 0xE0, 0xE0, 0x20, 0x00, 0x00, 0xE0, 0xE0, 
.................... 0xE0, 0x00, 0x00, 0x80, 0xC0, 0xE0, 0x60, 0x60, 0xE0, 0xC0, 0x80, 0x00, 0x00, 0x80, 0xC0, 0xE0, 
.................... 0xE0, 0x60, 0xE0, 0xE0, 0xC0, 0x80, 0x00, 0x01, 0x02, 0x02, 0x07, 0x04, 0x08, 0x00, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x7F, 0x7F, 0x01, 0x0F, 0x7C, 0x7C, 0x0F, 0x01, 0x7F, 0x7F, 0x00, 0x00, 0x7F, 
.................... 0x7F, 0x7F, 0x66, 0x66, 0x66, 0x66, 0x00, 0x40, 0x70, 0x7D, 0x3F, 0x0F, 0x3F, 0x7D, 0x70, 0x40, 
.................... 0x00, 0x00, 0x7F, 0x7F, 0x7F, 0x00, 0x00, 0x1F, 0x3F, 0x7F, 0x60, 0x60, 0x78, 0x38, 0x10, 0x00, 
.................... 0x00, 0x1F, 0x3F, 0x7F, 0x70, 0x60, 0x70, 0x7F, 0x3F, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 
.................... 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,  
.................... }; 
....................  
....................  
.................... static const unsigned char font[]= { 
.................... 	0x00, 0x00, 0x00, 0x00, 0x00, 
.................... 	0x3E, 0x5B, 0x4F, 0x5B, 0x3E, 
.................... 	0x3E, 0x6B, 0x4F, 0x6B, 0x3E, 
.................... 	0x1C, 0x3E, 0x7C, 0x3E, 0x1C, 
.................... 	0x18, 0x3C, 0x7E, 0x3C, 0x18, 
.................... 	0x1C, 0x57, 0x7D, 0x57, 0x1C, 
.................... 	0x1C, 0x5E, 0x7F, 0x5E, 0x1C, 
.................... 	0x00, 0x18, 0x3C, 0x18, 0x00, 
.................... 	0xFF, 0xE7, 0xC3, 0xE7, 0xFF, 
.................... 	0x00, 0x18, 0x24, 0x18, 0x00, 
.................... 	0xFF, 0xE7, 0xDB, 0xE7, 0xFF, 
.................... 	0x30, 0x48, 0x3A, 0x06, 0x0E, 
.................... 	0x26, 0x29, 0x79, 0x29, 0x26, 
.................... 	0x40, 0x7F, 0x05, 0x05, 0x07, 
.................... 	0x40, 0x7F, 0x05, 0x25, 0x3F, 
.................... 	0x5A, 0x3C, 0xE7, 0x3C, 0x5A, 
.................... 	0x7F, 0x3E, 0x1C, 0x1C, 0x08, 
.................... 	0x08, 0x1C, 0x1C, 0x3E, 0x7F, 
.................... 	0x14, 0x22, 0x7F, 0x22, 0x14, 
.................... 	0x5F, 0x5F, 0x00, 0x5F, 0x5F, 
.................... 	0x06, 0x09, 0x7F, 0x01, 0x7F, 
.................... 	0x00, 0x66, 0x89, 0x95, 0x6A, 
.................... 	0x60, 0x60, 0x60, 0x60, 0x60, 
.................... 	0x94, 0xA2, 0xFF, 0xA2, 0x94, 
.................... 	0x08, 0x04, 0x7E, 0x04, 0x08, 
.................... 	0x10, 0x20, 0x7E, 0x20, 0x10, 
.................... 	0x08, 0x08, 0x2A, 0x1C, 0x08, 
.................... 	0x08, 0x1C, 0x2A, 0x08, 0x08, 
.................... 	0x1E, 0x10, 0x10, 0x10, 0x10, 
.................... 	0x0C, 0x1E, 0x0C, 0x1E, 0x0C, 
.................... 	0x30, 0x38, 0x3E, 0x38, 0x30, 
.................... 	0x06, 0x0E, 0x3E, 0x0E, 0x06, 
.................... 	0x00, 0x00, 0x00, 0x00, 0x00, 
.................... 	0x00, 0x00, 0x5F, 0x00, 0x00, 
.................... 	0x00, 0x07, 0x00, 0x07, 0x00, 
.................... 	0x14, 0x7F, 0x14, 0x7F, 0x14, 
.................... 	0x24, 0x2A, 0x7F, 0x2A, 0x12, 
.................... 	0x23, 0x13, 0x08, 0x64, 0x62, 
.................... 	0x36, 0x49, 0x56, 0x20, 0x50, 
.................... 	0x00, 0x08, 0x07, 0x03, 0x00, 
.................... 	0x00, 0x1C, 0x22, 0x41, 0x00, 
.................... 	0x00, 0x41, 0x22, 0x1C, 0x00, 
.................... 	0x2A, 0x1C, 0x7F, 0x1C, 0x2A, 
.................... 	0x08, 0x08, 0x3E, 0x08, 0x08, 
.................... 	0x00, 0x80, 0x70, 0x30, 0x00, 
.................... 	0x08, 0x08, 0x08, 0x08, 0x08, 
.................... 	0x00, 0x00, 0x60, 0x60, 0x00, 
.................... 	0x20, 0x10, 0x08, 0x04, 0x02, 
.................... 	0x3E, 0x51, 0x49, 0x45, 0x3E, 
.................... 	0x00, 0x42, 0x7F, 0x40, 0x00, 
.................... 	0x72, 0x49, 0x49, 0x49, 0x46, 
.................... 	0x21, 0x41, 0x49, 0x4D, 0x33, 
.................... 	0x18, 0x14, 0x12, 0x7F, 0x10, 
.................... 	0x27, 0x45, 0x45, 0x45, 0x39, 
.................... 	0x3C, 0x4A, 0x49, 0x49, 0x31, 
.................... 	0x41, 0x21, 0x11, 0x09, 0x07, 
.................... 	0x36, 0x49, 0x49, 0x49, 0x36, 
.................... 	0x46, 0x49, 0x49, 0x29, 0x1E, 
.................... 	0x00, 0x00, 0x14, 0x00, 0x00, 
.................... 	0x00, 0x40, 0x34, 0x00, 0x00, 
.................... 	0x00, 0x08, 0x14, 0x22, 0x41, 
.................... 	0x14, 0x14, 0x14, 0x14, 0x14, 
.................... 	0x00, 0x41, 0x22, 0x14, 0x08, 
.................... 	0x02, 0x01, 0x59, 0x09, 0x06, 
.................... 	0x3E, 0x41, 0x5D, 0x59, 0x4E, 
.................... 	0x7C, 0x12, 0x11, 0x12, 0x7C, 
.................... 	0x7F, 0x49, 0x49, 0x49, 0x36, 
.................... 	0x3E, 0x41, 0x41, 0x41, 0x22, 
.................... 	0x7F, 0x41, 0x41, 0x41, 0x3E, 
.................... 	0x7F, 0x49, 0x49, 0x49, 0x41, 
.................... 	0x7F, 0x09, 0x09, 0x09, 0x01, 
.................... 	0x3E, 0x41, 0x41, 0x51, 0x73, 
.................... 	0x7F, 0x08, 0x08, 0x08, 0x7F, 
.................... 	0x00, 0x41, 0x7F, 0x41, 0x00, 
.................... 	0x20, 0x40, 0x41, 0x3F, 0x01, 
.................... 	0x7F, 0x08, 0x14, 0x22, 0x41, 
.................... 	0x7F, 0x40, 0x40, 0x40, 0x40, 
.................... 	0x7F, 0x02, 0x1C, 0x02, 0x7F, 
.................... 	0x7F, 0x04, 0x08, 0x10, 0x7F, 
.................... 	0x3E, 0x41, 0x41, 0x41, 0x3E, 
.................... 	0x7F, 0x09, 0x09, 0x09, 0x06, 
.................... 	0x3E, 0x41, 0x51, 0x21, 0x5E, 
.................... 	0x7F, 0x09, 0x19, 0x29, 0x46, 
.................... 	0x26, 0x49, 0x49, 0x49, 0x32, 
.................... 	0x03, 0x01, 0x7F, 0x01, 0x03, 
.................... 	0x3F, 0x40, 0x40, 0x40, 0x3F, 
.................... 	0x1F, 0x20, 0x40, 0x20, 0x1F, 
.................... 	0x3F, 0x40, 0x38, 0x40, 0x3F, 
.................... 	0x63, 0x14, 0x08, 0x14, 0x63, 
.................... 	0x03, 0x04, 0x78, 0x04, 0x03, 
.................... 	0x61, 0x59, 0x49, 0x4D, 0x43, 
.................... 	0x00, 0x7F, 0x41, 0x41, 0x41, 
.................... 	0x02, 0x04, 0x08, 0x10, 0x20, 
.................... 	0x00, 0x41, 0x41, 0x41, 0x7F, 
.................... 	0x04, 0x02, 0x01, 0x02, 0x04, 
.................... 	0x40, 0x40, 0x40, 0x40, 0x40, 
.................... 	0x00, 0x03, 0x07, 0x08, 0x00, 
.................... 	0x20, 0x54, 0x54, 0x78, 0x40, 
.................... 	0x7F, 0x28, 0x44, 0x44, 0x38, 
.................... 	0x38, 0x44, 0x44, 0x44, 0x28, 
.................... 	0x38, 0x44, 0x44, 0x28, 0x7F, 
.................... 	0x38, 0x54, 0x54, 0x54, 0x18, 
.................... 	0x00, 0x08, 0x7E, 0x09, 0x02, 
.................... 	0x18, 0xA4, 0xA4, 0x9C, 0x78, 
.................... 	0x7F, 0x08, 0x04, 0x04, 0x78, 
.................... 	0x00, 0x44, 0x7D, 0x40, 0x00, 
.................... 	0x20, 0x40, 0x40, 0x3D, 0x00, 
.................... 	0x7F, 0x10, 0x28, 0x44, 0x00, 
.................... 	0x00, 0x41, 0x7F, 0x40, 0x00, 
.................... 	0x7C, 0x04, 0x78, 0x04, 0x78, 
.................... 	0x7C, 0x08, 0x04, 0x04, 0x78, 
.................... 	0x38, 0x44, 0x44, 0x44, 0x38, 
.................... 	0xFC, 0x18, 0x24, 0x24, 0x18, 
.................... 	0x18, 0x24, 0x24, 0x18, 0xFC, 
.................... 	0x7C, 0x08, 0x04, 0x04, 0x08, 
.................... 	0x48, 0x54, 0x54, 0x54, 0x24, 
.................... 	0x04, 0x04, 0x3F, 0x44, 0x24, 
.................... 	0x3C, 0x40, 0x40, 0x20, 0x7C, 
.................... 	0x1C, 0x20, 0x40, 0x20, 0x1C, 
.................... 	0x3C, 0x40, 0x30, 0x40, 0x3C, 
.................... 	0x44, 0x28, 0x10, 0x28, 0x44, 
.................... 	0x4C, 0x90, 0x90, 0x90, 0x7C, 
.................... 	0x44, 0x64, 0x54, 0x4C, 0x44, 
.................... 	0x00, 0x08, 0x36, 0x41, 0x00, 
.................... 	0x00, 0x00, 0x77, 0x00, 0x00, 
.................... 	0x00, 0x41, 0x36, 0x08, 0x00, 
.................... 	0x02, 0x01, 0x02, 0x04, 0x02, 
.................... 	0x3C, 0x26, 0x23, 0x26, 0x3C, 
.................... 	0x1E, 0xA1, 0xA1, 0x61, 0x12, 
.................... 	0x3A, 0x40, 0x40, 0x20, 0x7A, 
.................... 	0x38, 0x54, 0x54, 0x55, 0x59, 
.................... 	0x21, 0x55, 0x55, 0x79, 0x41, 
.................... 	0x22, 0x54, 0x54, 0x78, 0x42, // a-umlaut 
.................... 	0x21, 0x55, 0x54, 0x78, 0x40, 
.................... 	0x20, 0x54, 0x55, 0x79, 0x40, 
.................... 	0x0C, 0x1E, 0x52, 0x72, 0x12, 
.................... 	0x39, 0x55, 0x55, 0x55, 0x59, 
.................... 	0x39, 0x54, 0x54, 0x54, 0x59, 
.................... 	0x39, 0x55, 0x54, 0x54, 0x58, 
.................... 	0x00, 0x00, 0x45, 0x7C, 0x41, 
.................... 	0x00, 0x02, 0x45, 0x7D, 0x42, 
.................... 	0x00, 0x01, 0x45, 0x7C, 0x40, 
.................... 	0x7D, 0x12, 0x11, 0x12, 0x7D, // A-umlaut 
.................... 	0xF0, 0x28, 0x25, 0x28, 0xF0, 
.................... 	0x7C, 0x54, 0x55, 0x45, 0x00, 
.................... 	0x20, 0x54, 0x54, 0x7C, 0x54, 
.................... 	0x7C, 0x0A, 0x09, 0x7F, 0x49, 
.................... 	0x32, 0x49, 0x49, 0x49, 0x32, 
.................... 	0x3A, 0x44, 0x44, 0x44, 0x3A, // o-umlaut 
.................... 	0x32, 0x4A, 0x48, 0x48, 0x30, 
.................... 	0x3A, 0x41, 0x41, 0x21, 0x7A, 
.................... 	0x3A, 0x42, 0x40, 0x20, 0x78, 
.................... 	0x00, 0x9D, 0xA0, 0xA0, 0x7D, 
.................... 	0x3D, 0x42, 0x42, 0x42, 0x3D, // O-umlaut 
.................... 	0x3D, 0x40, 0x40, 0x40, 0x3D, 
.................... 	0x3C, 0x24, 0xFF, 0x24, 0x24, 
.................... 	0x48, 0x7E, 0x49, 0x43, 0x66, 
.................... 	0x2B, 0x2F, 0xFC, 0x2F, 0x2B, 
.................... 	0xFF, 0x09, 0x29, 0xF6, 0x20, 
.................... 	0xC0, 0x88, 0x7E, 0x09, 0x03, 
.................... 	0x20, 0x54, 0x54, 0x79, 0x41, 
.................... 	0x00, 0x00, 0x44, 0x7D, 0x41, 
.................... 	0x30, 0x48, 0x48, 0x4A, 0x32, 
.................... 	0x38, 0x40, 0x40, 0x22, 0x7A, 
.................... 	0x00, 0x7A, 0x0A, 0x0A, 0x72, 
.................... 	0x7D, 0x0D, 0x19, 0x31, 0x7D, 
.................... 	0x26, 0x29, 0x29, 0x2F, 0x28, 
.................... 	0x26, 0x29, 0x29, 0x29, 0x26, 
.................... 	0x30, 0x48, 0x4D, 0x40, 0x20, 
.................... 	0x38, 0x08, 0x08, 0x08, 0x08, 
.................... 	0x08, 0x08, 0x08, 0x08, 0x38, 
.................... 	0x2F, 0x10, 0xC8, 0xAC, 0xBA, 
.................... 	0x2F, 0x10, 0x28, 0x34, 0xFA, 
.................... 	0x00, 0x00, 0x7B, 0x00, 0x00, 
.................... 	0x08, 0x14, 0x2A, 0x14, 0x22, 
.................... 	0x22, 0x14, 0x2A, 0x14, 0x08, 
.................... 	0x55, 0x00, 0x55, 0x00, 0x55, // #176 (25% block) missing in old code 
.................... 	0xAA, 0x55, 0xAA, 0x55, 0xAA, // 50% block 
.................... 	0xFF, 0x55, 0xFF, 0x55, 0xFF, // 75% block 
.................... 	0x00, 0x00, 0x00, 0xFF, 0x00, 
.................... 	0x10, 0x10, 0x10, 0xFF, 0x00, 
.................... 	0x14, 0x14, 0x14, 0xFF, 0x00, 
.................... 	0x10, 0x10, 0xFF, 0x00, 0xFF, 
.................... 	0x10, 0x10, 0xF0, 0x10, 0xF0, 
.................... 	0x14, 0x14, 0x14, 0xFC, 0x00, 
.................... 	0x14, 0x14, 0xF7, 0x00, 0xFF, 
.................... 	0x00, 0x00, 0xFF, 0x00, 0xFF, 
.................... 	0x14, 0x14, 0xF4, 0x04, 0xFC, 
.................... 	0x14, 0x14, 0x17, 0x10, 0x1F, 
.................... 	0x10, 0x10, 0x1F, 0x10, 0x1F, 
.................... 	0x14, 0x14, 0x14, 0x1F, 0x00, 
.................... 	0x10, 0x10, 0x10, 0xF0, 0x00, 
.................... 	0x00, 0x00, 0x00, 0x1F, 0x10, 
.................... 	0x10, 0x10, 0x10, 0x1F, 0x10, 
.................... 	0x10, 0x10, 0x10, 0xF0, 0x10, 
.................... 	0x00, 0x00, 0x00, 0xFF, 0x10, 
.................... 	0x10, 0x10, 0x10, 0x10, 0x10, 
.................... 	0x10, 0x10, 0x10, 0xFF, 0x10, 
.................... 	0x00, 0x00, 0x00, 0xFF, 0x14, 
.................... 	0x00, 0x00, 0xFF, 0x00, 0xFF, 
.................... 	0x00, 0x00, 0x1F, 0x10, 0x17, 
.................... 	0x00, 0x00, 0xFC, 0x04, 0xF4, 
.................... 	0x14, 0x14, 0x17, 0x10, 0x17, 
.................... 	0x14, 0x14, 0xF4, 0x04, 0xF4, 
.................... 	0x00, 0x00, 0xFF, 0x00, 0xF7, 
.................... 	0x14, 0x14, 0x14, 0x14, 0x14, 
.................... 	0x14, 0x14, 0xF7, 0x00, 0xF7, 
.................... 	0x14, 0x14, 0x14, 0x17, 0x14, 
.................... 	0x10, 0x10, 0x1F, 0x10, 0x1F, 
.................... 	0x14, 0x14, 0x14, 0xF4, 0x14, 
.................... 	0x10, 0x10, 0xF0, 0x10, 0xF0, 
.................... 	0x00, 0x00, 0x1F, 0x10, 0x1F, 
.................... 	0x00, 0x00, 0x00, 0x1F, 0x14, 
.................... 	0x00, 0x00, 0x00, 0xFC, 0x14, 
.................... 	0x00, 0x00, 0xF0, 0x10, 0xF0, 
.................... 	0x10, 0x10, 0xFF, 0x10, 0xFF, 
.................... 	0x14, 0x14, 0x14, 0xFF, 0x14, 
.................... 	0x10, 0x10, 0x10, 0x1F, 0x00, 
.................... 	0x00, 0x00, 0x00, 0xF0, 0x10, 
.................... 	0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 
.................... 	0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 
.................... 	0xFF, 0xFF, 0xFF, 0x00, 0x00, 
.................... 	0x00, 0x00, 0x00, 0xFF, 0xFF, 
.................... 	0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 
.................... 	0x38, 0x44, 0x44, 0x38, 0x44, 
.................... 	0xFC, 0x4A, 0x4A, 0x4A, 0x34, // sharp-s or beta 
.................... 	0x7E, 0x02, 0x02, 0x06, 0x06, 
.................... 	0x02, 0x7E, 0x02, 0x7E, 0x02, 
.................... 	0x63, 0x55, 0x49, 0x41, 0x63, 
.................... 	0x38, 0x44, 0x44, 0x3C, 0x04, 
.................... 	0x40, 0x7E, 0x20, 0x1E, 0x20, 
.................... 	0x06, 0x02, 0x7E, 0x02, 0x02, 
.................... 	0x99, 0xA5, 0xE7, 0xA5, 0x99, 
.................... 	0x1C, 0x2A, 0x49, 0x2A, 0x1C, 
.................... 	0x4C, 0x72, 0x01, 0x72, 0x4C, 
.................... 	0x30, 0x4A, 0x4D, 0x4D, 0x30, 
.................... 	0x30, 0x48, 0x78, 0x48, 0x30, 
.................... 	0xBC, 0x62, 0x5A, 0x46, 0x3D, 
.................... 	0x3E, 0x49, 0x49, 0x49, 0x00, 
.................... 	0x7E, 0x01, 0x01, 0x01, 0x7E, 
.................... 	0x2A, 0x2A, 0x2A, 0x2A, 0x2A, 
.................... 	0x44, 0x44, 0x5F, 0x44, 0x44, 
.................... 	0x40, 0x51, 0x4A, 0x44, 0x40, 
.................... 	0x40, 0x44, 0x4A, 0x51, 0x40, 
.................... 	0x00, 0x00, 0xFF, 0x01, 0x03, 
.................... 	0xE0, 0x80, 0xFF, 0x00, 0x00, 
.................... 	0x08, 0x08, 0x6B, 0x6B, 0x08, 
.................... 	0x36, 0x12, 0x36, 0x24, 0x36, 
.................... 	0x06, 0x0F, 0x09, 0x0F, 0x06, 
.................... 	0x00, 0x00, 0x18, 0x18, 0x00, 
.................... 	0x00, 0x00, 0x10, 0x10, 0x00, 
.................... 	0x30, 0x40, 0xFF, 0x01, 0x01, 
.................... 	0x00, 0x1F, 0x01, 0x01, 0x1E, 
.................... 	0x00, 0x19, 0x1D, 0x17, 0x12, 
.................... 	0x00, 0x3C, 0x3C, 0x3C, 0x3C, 
.................... 	0x00, 0x00, 0x00, 0x00, 0x00  // #255 NBSP 
.................... }; 
....................  
....................   void PCD_begin(uint8_t contrast = 40, uint8_t bias = 0x04) 
.................... 	{ 
.................... 		output_low(_RST); 
*
0764:  BCF    F93.2
0766:  BCF    F8A.2
.................... 		delay_ms(200); 
0768:  MOVLW  C8
076A:  MOVLB  2
076C:  MOVWF  x73
076E:  MOVLB  0
0770:  RCALL  06FC
.................... 		output_high(_RST); 
0772:  BCF    F93.2
0774:  BSF    F8A.2
....................   		// get into the EXTENDED mode! 
....................   		PCD_command(PCD8544_FUNCTIONSET | PCD8544_EXTENDEDINSTRUCTION ); 
0776:  MOVLW  21
0778:  MOVLB  2
077A:  MOVWF  x79
077C:  MOVLB  0
077E:  RCALL  0750
....................   		// LCD bias select (4 is optimal?) 
....................   		PCD_command(PCD8544_SETBIAS | bias); 
0780:  MOVLB  2
0782:  MOVF   x72,W
0784:  IORLW  10
0786:  MOVWF  x73
0788:  MOVWF  x79
078A:  MOVLB  0
078C:  RCALL  0750
....................   		// set VOP 
....................   		if (contrast > 0x7f) 
078E:  MOVLB  2
0790:  MOVF   x71,W
0792:  SUBLW  7F
0794:  BC    079A
....................     	contrast = 0x7f; 
0796:  MOVLW  7F
0798:  MOVWF  x71
....................   		PCD_command( PCD8544_SETVOP | contrast); // Experimentally determined 
079A:  MOVF   x71,W
079C:  IORLW  80
079E:  MOVWF  x73
07A0:  MOVWF  x79
07A2:  MOVLB  0
07A4:  RCALL  0750
....................   		// normal mode 
....................   		PCD_command(PCD8544_FUNCTIONSET); 
07A6:  MOVLW  20
07A8:  MOVLB  2
07AA:  MOVWF  x79
07AC:  MOVLB  0
07AE:  RCALL  0750
....................   		// Set display to Normal 
....................   		PCD_command(PCD8544_DISPLAYCONTROL | PCD8544_DISPLAYNORMAL);		 
07B0:  MOVLW  0C
07B2:  MOVLB  2
07B4:  MOVWF  x79
07B6:  MOVLB  0
07B8:  RCALL  0750
.................... 	}   
07BA:  GOTO   10AA (RETURN)
....................   void PCD_command(uint8_t c) 
.................... 	{ 
....................   		output_low(_DC);//digitalWrite(_dc, LOW); 
*
0750:  BCF    F93.0
0752:  BCF    F8A.0
....................     	output_low(_CE);//digitalWrite(_cs, LOW); 
0754:  BCF    F93.1
0756:  BCF    F8A.1
....................   		PCD_spiWrite(c); 
0758:  MOVFF  279,27A
075C:  RCALL  0724
....................     	output_high(_CE);//digitalWrite(_cs, HIGH); 
075E:  BCF    F93.1
0760:  BSF    F8A.1
.................... 	} 
0762:  RETLW  00
....................   void PCD_data(uint8_t c) 
.................... 	{ 
....................   		output_high(_DC);//digitalWrite(_dc, LOW); 
....................     	output_low(_CE);//digitalWrite(_cs, LOW); 
....................   		PCD_spiWrite(c); 
....................     	output_high(_CE);//digitalWrite(_cs, HIGH); 
.................... 	}   
....................   void PCD_setContrast(uint8_t val) 
.................... 	{ 
....................   		if (val > 0x7f) { 
*
07BE:  MOVLB  2
07C0:  MOVF   x71,W
07C2:  SUBLW  7F
07C4:  BC    07CA
....................     	val = 0x7f; 
07C6:  MOVLW  7F
07C8:  MOVWF  x71
....................   		} 
....................   		PCD_command(PCD8544_FUNCTIONSET | PCD8544_EXTENDEDINSTRUCTION ); 
07CA:  MOVLW  21
07CC:  MOVWF  x79
07CE:  MOVLB  0
07D0:  RCALL  0750
....................   		PCD_command( PCD8544_SETVOP | val);  
07D2:  MOVLB  2
07D4:  MOVF   x71,W
07D6:  IORLW  80
07D8:  MOVWF  x72
07DA:  MOVWF  x79
07DC:  MOVLB  0
07DE:  RCALL  0750
....................   		PCD_command(PCD8544_FUNCTIONSET); 
07E0:  MOVLW  20
07E2:  MOVLB  2
07E4:  MOVWF  x79
07E6:  MOVLB  0
07E8:  RCALL  0750
.................... 	} 
07EA:  GOTO   10B6 (RETURN)
....................   void PCD_clearDisplay() 
.................... 	{ 
*
08C0:  MOVLB  2
08C2:  CLRF   x72
08C4:  CLRF   x71
.................... 		uint16_t i=0; 
.................... 		for(;i<LCDWIDTH*LCDHEIGHT/8;i++)pcd8544_buffer[i]=0x00; 
08C6:  MOVF   x72,W
08C8:  SUBLW  01
08CA:  BNC   08EA
08CC:  BNZ   08D4
08CE:  MOVF   x71,W
08D0:  SUBLW  F7
08D2:  BNC   08EA
08D4:  MOVLW  22
08D6:  ADDWF  x71,W
08D8:  MOVWF  FE9
08DA:  MOVLW  00
08DC:  ADDWFC x72,W
08DE:  MOVWF  FEA
08E0:  CLRF   FEF
08E2:  INCF   x71,F
08E4:  BTFSC  FD8.2
08E6:  INCF   x72,F
08E8:  BRA    08C6
.................... 	} 
08EA:  MOVLB  0
08EC:  RETLW  00
....................   void PCD_display() 
.................... 	{ 
....................   		uint16_t col, maxcol, p;   
....................  		for(p = 0; p < 6; p++)  
*
0810:  MOVLB  2
0812:  CLRF   x76
0814:  CLRF   x75
0816:  MOVF   x76,F
0818:  BNZ   08B6
081A:  MOVF   x75,W
081C:  SUBLW  05
081E:  BNC   08B6
.................... 		{ 
....................     		PCD_command(PCD8544_SETYADDR | p); 
0820:  MOVF   x75,W
0822:  IORLW  40
0824:  MOVWF  x77
0826:  MOVFF  276,278
082A:  MOVWF  x79
082C:  MOVLB  0
082E:  RCALL  0750
....................    			col = 0; 
0830:  MOVLB  2
0832:  CLRF   x72
0834:  CLRF   x71
....................     		maxcol = LCDWIDTH-1; 
0836:  CLRF   x74
0838:  MOVLW  53
083A:  MOVWF  x73
....................     		PCD_command(PCD8544_SETXADDR | col); 
083C:  MOVF   x71,W
083E:  IORLW  80
0840:  MOVWF  x77
0842:  MOVFF  272,278
0846:  MOVWF  x79
0848:  MOVLB  0
084A:  RCALL  0750
....................     		output_high(_DC);//digitalWrite(_dc, HIGH); 
084C:  BCF    F93.0
084E:  BSF    F8A.0
....................       		output_low(_CE);//digitalWrite(_cs, LOW); 
0850:  BCF    F93.1
0852:  BCF    F8A.1
....................     		for(; col <= maxcol; col++) { 
0854:  MOVLB  2
0856:  MOVF   x72,W
0858:  SUBWF  x74,W
085A:  BNC   08AA
085C:  BNZ   0864
085E:  MOVF   x71,W
0860:  SUBWF  x73,W
0862:  BNC   08AA
....................       			PCD_spiWrite(pcd8544_buffer[(LCDWIDTH*p)+col]); 
0864:  CLRF   x7B
0866:  MOVLW  54
0868:  MOVWF  x7A
086A:  MOVFF  276,27D
086E:  MOVFF  275,27C
0872:  MOVLB  0
0874:  RCALL  07EE
0876:  MOVFF  02,278
087A:  MOVFF  01,277
087E:  MOVLB  2
0880:  MOVF   x71,W
0882:  ADDWF  x77,F
0884:  MOVF   x72,W
0886:  ADDWFC x78,F
0888:  MOVLW  22
088A:  ADDWF  x77,W
088C:  MOVWF  FE9
088E:  MOVLW  00
0890:  ADDWFC x78,W
0892:  MOVWF  FEA
0894:  MOVFF  FEF,277
0898:  MOVFF  277,27A
089C:  MOVLB  0
089E:  RCALL  0724
....................     		} 
08A0:  MOVLB  2
08A2:  INCF   x71,F
08A4:  BTFSC  FD8.2
08A6:  INCF   x72,F
08A8:  BRA    0856
....................       		output_high(_CE);//digitalWrite(_cs, HIGH); 
08AA:  BCF    F93.1
08AC:  BSF    F8A.1
....................   		} 
08AE:  INCF   x75,F
08B0:  BTFSC  FD8.2
08B2:  INCF   x76,F
08B4:  BRA    0816
....................   		PCD_command(PCD8544_SETYADDR );  // no idea why this is necessary but it is to finish the last byte? 
08B6:  MOVLW  40
08B8:  MOVWF  x79
08BA:  MOVLB  0
08BC:  RCALL  0750
.................... 	} 
08BE:  RETLW  00
....................   void PCD_drawPixel(int16_t x, int16_t y, uint16_t color) 
.................... 	{ 
....................   		if ((x < 0) || (x >= LCDWIDTH) || (y < 0) || (y >= LCDHEIGHT)) 
....................     	return; 
....................  
....................   // x is which column 
....................   		if (color)  
....................     	pcd8544_buffer[x+ (y/8)*LCDWIDTH] |= 1 << (y%8);   
....................   		else 
....................    		pcd8544_buffer[x+ (y/8)*LCDWIDTH] &= ~(1 << (y%8));  
.................... 	} 
....................   unsigned int8 PCD_getPixel(int8_t x, int8_t y) 
.................... 	{ 
.................... 		return 0; 
.................... 	} 
....................  
....................   void PCD_spiWrite(uint8_t d)  
.................... 	{ 
.................... 		uint8_t vbit; 
....................     	for(vbit = 0x80; vbit; vbit >>= 1) 
*
0724:  MOVLW  80
0726:  MOVLB  2
0728:  MOVWF  x7B
072A:  MOVF   x7B,F
072C:  BZ    074C
.................... 		{ 
....................      		output_low(_CLK);//PINB0=0;// 
072E:  BCF    F93.5
0730:  BCF    F8A.5
....................      	 	if(d & vbit) output_high(_DIN);//PINB1=1;// 
0732:  MOVF   x7A,W
0734:  ANDWF  x7B,W
0736:  BZ    073E
0738:  BCF    F93.4
073A:  BSF    F8A.4
....................       		else         output_low(_DIN);//PINB1=0;// 
073C:  BRA    0742
073E:  BCF    F93.4
0740:  BCF    F8A.4
....................       		output_high(_CLK);//PINB0=1;// 
0742:  BCF    F93.5
0744:  BSF    F8A.5
....................     	} 
0746:  BCF    FD8.0
0748:  RRCF   x7B,F
074A:  BRA    072A
....................  		 
.................... 	}	 
074C:  MOVLB  0
074E:  RETLW  00
....................   void PCD_drawChart(char c) 
.................... 	{ 
*
0900:  MOVLB  2
0902:  CLRF   x75
0904:  CLRF   x74
0906:  CLRF   x77
0908:  MOVFF  273,276
.................... 		uint16_t i=0; 
.................... 		uint16_t font_index=(uint16_t)c; 
.................... 		for(;i<6;i++) 
090C:  MOVF   x75,F
090E:  BTFSS  FD8.2
0910:  BRA    09FE
0912:  MOVF   x74,W
0914:  SUBLW  05
0916:  BNC   09FE
.................... 			{ 
.................... 				if(i<5)pcd8544_buffer[(cursor_y/8)*LCDWIDTH+cursor_x]=font[(font_index*5)+i]; 
0918:  MOVF   x75,F
091A:  BNZ   09AA
091C:  MOVF   x74,W
091E:  SUBLW  04
0920:  BNC   09AA
0922:  RRCF   21,W
0924:  MOVWF  x79
0926:  RRCF   20,W
0928:  MOVWF  x78
092A:  RRCF   x79,F
092C:  RRCF   x78,F
092E:  RRCF   x79,F
0930:  RRCF   x78,F
0932:  MOVLW  1F
0934:  ANDWF  x79,F
0936:  MOVFF  279,27B
093A:  MOVFF  278,27A
093E:  CLRF   x7D
0940:  MOVLW  54
0942:  MOVWF  x7C
0944:  MOVLB  0
0946:  RCALL  07EE
0948:  MOVFF  02,279
094C:  MOVFF  01,278
0950:  MOVF   1E,W
0952:  MOVLB  2
0954:  ADDWF  x78,F
0956:  MOVF   1F,W
0958:  ADDWFC x79,F
095A:  MOVLW  22
095C:  ADDWF  x78,W
095E:  MOVWF  FE9
0960:  MOVLW  00
0962:  ADDWFC x79,W
0964:  MOVWF  FEA
0966:  MOVFF  277,27B
096A:  MOVFF  276,27A
096E:  CLRF   x7D
0970:  MOVLW  05
0972:  MOVWF  x7C
0974:  MOVLB  0
0976:  RCALL  07EE
0978:  MOVFF  02,27B
097C:  MOVFF  01,27A
0980:  MOVLB  2
0982:  MOVF   x74,W
0984:  ADDWF  x7A,F
0986:  MOVF   x75,W
0988:  ADDWFC x7B,F
098A:  MOVFF  27B,03
098E:  MOVF   x7A,W
0990:  MOVFF  FF2,27A
0994:  BCF    FF2.7
0996:  MOVFF  27B,FF7
099A:  MOVLB  0
099C:  CALL   0096
09A0:  MOVLB  2
09A2:  BTFSC  x7A.7
09A4:  BSF    FF2.7
09A6:  MOVWF  FEF
.................... 				else pcd8544_buffer[(cursor_y/8)*LCDWIDTH+cursor_x]=0;	 
09A8:  BRA    09F0
09AA:  RRCF   21,W
09AC:  MOVWF  x79
09AE:  RRCF   20,W
09B0:  MOVWF  x78
09B2:  RRCF   x79,F
09B4:  RRCF   x78,F
09B6:  RRCF   x79,F
09B8:  RRCF   x78,F
09BA:  MOVLW  1F
09BC:  ANDWF  x79,F
09BE:  MOVFF  279,27B
09C2:  MOVFF  278,27A
09C6:  CLRF   x7D
09C8:  MOVLW  54
09CA:  MOVWF  x7C
09CC:  MOVLB  0
09CE:  RCALL  07EE
09D0:  MOVFF  02,279
09D4:  MOVFF  01,278
09D8:  MOVF   1E,W
09DA:  MOVLB  2
09DC:  ADDWF  x78,F
09DE:  MOVF   1F,W
09E0:  ADDWFC x79,F
09E2:  MOVLW  22
09E4:  ADDWF  x78,W
09E6:  MOVWF  FE9
09E8:  MOVLW  00
09EA:  ADDWFC x79,W
09EC:  MOVWF  FEA
09EE:  CLRF   FEF
.................... 				cursor_x++; 
09F0:  INCF   1E,F
09F2:  BTFSC  FD8.2
09F4:  INCF   1F,F
.................... 			} 
09F6:  INCF   x74,F
09F8:  BTFSC  FD8.2
09FA:  INCF   x75,F
09FC:  BRA    090C
.................... 		//pcd8544_buffer[(cursor_y/8)*LCDWIDTH+cursor_x+1]=0; 
.................... 	} 
09FE:  MOVLB  0
0A00:  RETLW  00
....................   void PCD_setCursor(uint16_t x, uint16_t y) 
.................... 	{ 
.................... 		cursor_x=x; 
*
08EE:  MOVFF  272,1F
08F2:  MOVFF  271,1E
.................... 		cursor_y=y; 
08F6:  MOVFF  274,21
08FA:  MOVFF  273,20
.................... 	} 
08FE:  RETLW  00
....................  
.................... char InputBuffer[85]={0}; 
.................... unsigned int option=0,i=0; 
....................  
.................... #INT_RDA 
.................... void isr() 
.................... { 
*
0612:  MOVLB  2
0614:  CLRF   x80
0616:  CLRF   x7F
0618:  CLRF   x81
.................... 	int16 index=0; 
.................... 	char c=0; 
....................     do 
....................     {	 
.................... 		c=getc(); 
061A:  MOVLB  0
061C:  RCALL  05AE
061E:  MOVFF  01,281
....................     }while(index<84 && c!=':'&& c!=0);//'\n'); 
0622:  MOVLB  2
0624:  MOVF   x80,F
0626:  BNZ   0638
0628:  MOVF   x7F,W
062A:  SUBLW  53
062C:  BNC   0638
062E:  MOVF   x81,W
0630:  SUBLW  3A
0632:  BZ    0638
0634:  MOVF   x81,F
0636:  BNZ   061A
.................... 	if(c!=0) 
0638:  MOVF   x81,F
063A:  BZ    06D4
.................... 	{ 
.................... 		do 
....................     	{ 
....................        		InputBuffer[index]=getc();	 
063C:  MOVLW  1A
063E:  ADDWF  x7F,W
0640:  MOVWF  FE9
0642:  MOVLW  02
0644:  ADDWFC x80,W
0646:  MOVWF  FEA
0648:  MOVFF  FEA,285
064C:  MOVFF  FE9,284
0650:  MOVLB  0
0652:  RCALL  05AE
0654:  MOVFF  285,FEA
0658:  MOVFF  284,FE9
065C:  MOVFF  01,FEF
.................... 			index++; 
0660:  MOVLB  2
0662:  INCF   x7F,F
0664:  BTFSC  FD8.2
0666:  INCF   x80,F
....................     	}while(index<84 && InputBuffer[index-1]!=','&& InputBuffer[index-1]!=0);//'\n'); 
0668:  MOVF   x80,F
066A:  BNZ   06AC
066C:  MOVF   x7F,W
066E:  SUBLW  53
0670:  BNC   06AC
0672:  MOVLW  01
0674:  SUBWF  x7F,W
0676:  MOVWF  x82
0678:  MOVLW  00
067A:  SUBWFB x80,W
067C:  MOVWF  x83
067E:  MOVLW  1A
0680:  ADDWF  x82,W
0682:  MOVWF  FE9
0684:  MOVLW  02
0686:  ADDWFC x83,W
0688:  MOVWF  FEA
068A:  MOVF   FEF,W
068C:  SUBLW  2C
068E:  BZ    06AC
0690:  MOVLW  01
0692:  SUBWF  x7F,W
0694:  MOVWF  x82
0696:  MOVLW  00
0698:  SUBWFB x80,W
069A:  MOVWF  x83
069C:  MOVLW  1A
069E:  ADDWF  x82,W
06A0:  MOVWF  FE9
06A2:  MOVLW  02
06A4:  ADDWFC x83,W
06A6:  MOVWF  FEA
06A8:  MOVF   FEF,F
06AA:  BNZ   063C
.................... 		InputBuffer[index-1]=0; 
06AC:  MOVLW  01
06AE:  SUBWF  x7F,W
06B0:  MOVWF  x82
06B2:  MOVLW  00
06B4:  SUBWFB x80,W
06B6:  MOVWF  x83
06B8:  MOVLW  1A
06BA:  ADDWF  x82,W
06BC:  MOVWF  FE9
06BE:  MOVLW  02
06C0:  ADDWFC x83,W
06C2:  MOVWF  FEA
06C4:  CLRF   FEF
.................... 		printf("%s",InputBuffer); 
06C6:  MOVLW  02
06C8:  MOVWF  FEA
06CA:  MOVLW  1A
06CC:  MOVWF  FE9
06CE:  MOVLB  0
06D0:  RCALL  05EC
06D2:  MOVLB  2
.................... 	} 
.................... output_toggle(PIN_B3); 
06D4:  BCF    F93.3
06D6:  BTG    F8A.3
.................... } 
....................  
06D8:  BCF    F9E.5
06DA:  MOVLB  0
06DC:  GOTO   0054
.................... void main(void) 
.................... { 
*
0A74:  CLRF   FF8
0A76:  BCF    FD0.7
0A78:  BSF    07.7
0A7A:  CLRF   FEA
0A7C:  CLRF   FE9
0A7E:  BSF    FB8.3
0A80:  MOVLW  10
0A82:  MOVWF  FAF
0A84:  MOVLW  00
0A86:  MOVWF  FB0
0A88:  MOVLW  A6
0A8A:  MOVWF  FAC
0A8C:  MOVLW  90
0A8E:  MOVWF  FAB
0A90:  MOVLB  2
0A92:  CLRF   x6F
0A94:  CLRF   x70
0A96:  MOVF   FC1,W
0A98:  ANDLW  C0
0A9A:  IORLW  0F
0A9C:  MOVWF  FC1
0A9E:  MOVLW  07
0AA0:  MOVWF  FB4
0AA2:  CLRF   17
0AA4:  CLRF   18
0AA6:  CLRF   19
0AA8:  CLRF   22
0AAA:  CLRF   23
0AAC:  CLRF   24
0AAE:  CLRF   25
0AB0:  CLRF   26
0AB2:  CLRF   27
0AB4:  CLRF   28
0AB6:  CLRF   29
0AB8:  CLRF   2A
0ABA:  CLRF   2B
0ABC:  CLRF   2C
0ABE:  CLRF   2D
0AC0:  CLRF   2E
0AC2:  CLRF   2F
0AC4:  CLRF   30
0AC6:  CLRF   31
0AC8:  CLRF   32
0ACA:  CLRF   33
0ACC:  CLRF   34
0ACE:  CLRF   35
0AD0:  CLRF   36
0AD2:  CLRF   37
0AD4:  CLRF   38
0AD6:  CLRF   39
0AD8:  CLRF   3A
0ADA:  CLRF   3B
0ADC:  CLRF   3C
0ADE:  CLRF   3D
0AE0:  CLRF   3E
0AE2:  CLRF   3F
0AE4:  CLRF   40
0AE6:  CLRF   41
0AE8:  CLRF   42
0AEA:  CLRF   43
0AEC:  CLRF   44
0AEE:  CLRF   45
0AF0:  CLRF   46
0AF2:  CLRF   47
0AF4:  CLRF   48
0AF6:  CLRF   49
0AF8:  MOVLW  40
0AFA:  MOVWF  4A
0AFC:  MOVWF  4B
0AFE:  MOVLW  44
0B00:  MOVWF  4C
0B02:  MOVWF  4D
0B04:  MOVWF  4E
0B06:  MOVLW  84
0B08:  MOVWF  4F
0B0A:  MOVWF  50
0B0C:  MOVLW  08
0B0E:  MOVWF  51
0B10:  MOVWF  52
0B12:  MOVLW  10
0B14:  MOVWF  53
0B16:  MOVLW  20
0B18:  MOVWF  54
0B1A:  MOVLW  C0
0B1C:  MOVWF  55
0B1E:  CLRF   56
0B20:  CLRF   57
0B22:  CLRF   58
0B24:  MOVLW  40
0B26:  MOVWF  59
0B28:  MOVLW  A0
0B2A:  MOVWF  5A
0B2C:  MOVWF  5B
0B2E:  MOVLW  10
0B30:  MOVWF  5C
0B32:  MOVWF  5D
0B34:  MOVLW  08
0B36:  MOVWF  5E
0B38:  MOVWF  5F
0B3A:  MOVLW  04
0B3C:  MOVLB  0
0B3E:  MOVWF  x60
0B40:  MOVWF  x61
0B42:  MOVLW  02
0B44:  MOVWF  x62
0B46:  MOVLW  06
0B48:  MOVWF  x63
0B4A:  MOVLW  08
0B4C:  MOVWF  x64
0B4E:  MOVLW  30
0B50:  MOVWF  x65
0B52:  MOVLW  40
0B54:  MOVWF  x66
0B56:  MOVLW  80
0B58:  MOVWF  x67
0B5A:  CLRF   x68
0B5C:  CLRF   x69
0B5E:  CLRF   x6A
0B60:  CLRF   x6B
0B62:  CLRF   x6C
0B64:  CLRF   x6D
0B66:  CLRF   x6E
0B68:  CLRF   x6F
0B6A:  CLRF   x70
0B6C:  CLRF   x71
0B6E:  CLRF   x72
0B70:  CLRF   x73
0B72:  CLRF   x74
0B74:  CLRF   x75
0B76:  CLRF   x76
0B78:  CLRF   x77
0B7A:  CLRF   x78
0B7C:  MOVWF  x79
0B7E:  MOVLW  E0
0B80:  MOVWF  x7A
0B82:  MOVLW  F0
0B84:  MOVWF  x7B
0B86:  MOVLW  F8
0B88:  MOVWF  x7C
0B8A:  MOVLW  FC
0B8C:  MOVWF  x7D
0B8E:  MOVLW  3C
0B90:  MOVWF  x7E
0B92:  MOVLW  1C
0B94:  MOVWF  x7F
0B96:  MOVWF  x80
0B98:  MOVWF  x81
0B9A:  MOVWF  x82
0B9C:  MOVLW  7C
0B9E:  MOVWF  x83
0BA0:  MOVWF  x84
0BA2:  MOVLW  78
0BA4:  MOVWF  x85
0BA6:  MOVLW  30
0BA8:  MOVWF  x86
0BAA:  CLRF   x87
0BAC:  CLRF   x88
0BAE:  CLRF   x89
0BB0:  CLRF   x8A
0BB2:  MOVLW  80
0BB4:  MOVWF  x8B
0BB6:  MOVWF  x8C
0BB8:  MOVWF  x8D
0BBA:  MOVWF  x8E
0BBC:  MOVWF  x8F
0BBE:  CLRF   x90
0BC0:  CLRF   x91
0BC2:  CLRF   x92
0BC4:  MOVWF  x93
0BC6:  MOVWF  x94
0BC8:  MOVWF  x95
0BCA:  MOVWF  x96
0BCC:  CLRF   x97
0BCE:  CLRF   x98
0BD0:  MOVWF  x99
0BD2:  MOVWF  x9A
0BD4:  MOVLW  B0
0BD6:  MOVWF  x9B
0BD8:  MOVLW  F8
0BDA:  MOVWF  x9C
0BDC:  MOVLW  79
0BDE:  MOVWF  x9D
0BE0:  MOVLW  31
0BE2:  MOVWF  x9E
0BE4:  MOVLW  01
0BE6:  MOVWF  x9F
0BE8:  MOVLW  02
0BEA:  MOVWF  xA0
0BEC:  MOVLW  C6
0BEE:  MOVWF  xA1
0BF0:  MOVLW  38
0BF2:  MOVWF  xA2
0BF4:  CLRF   xA3
0BF6:  MOVLW  81
0BF8:  MOVWF  xA4
0BFA:  MOVLW  42
0BFC:  MOVWF  xA5
0BFE:  MOVLW  3C
0C00:  MOVWF  xA6
0C02:  CLRF   xA7
0C04:  CLRF   xA8
0C06:  MOVLW  C1
0C08:  MOVWF  xA9
0C0A:  MOVLW  3E
0C0C:  MOVWF  xAA
0C0E:  CLRF   xAB
0C10:  CLRF   xAC
0C12:  CLRF   xAD
0C14:  CLRF   xAE
0C16:  CLRF   xAF
0C18:  MOVLW  01
0C1A:  MOVWF  xB0
0C1C:  MOVWF  xB1
0C1E:  MOVLW  02
0C20:  MOVWF  xB2
0C22:  MOVLW  24
0C24:  MOVWF  xB3
0C26:  MOVLW  34
0C28:  MOVWF  xB4
0C2A:  MOVLW  58
0C2C:  MOVWF  xB5
0C2E:  MOVLW  88
0C30:  MOVWF  xB6
0C32:  MOVLW  80
0C34:  MOVWF  xB7
0C36:  CLRF   xB8
0C38:  CLRF   xB9
0C3A:  MOVLW  02
0C3C:  MOVWF  xBA
0C3E:  MOVLW  06
0C40:  MOVWF  xBB
0C42:  MOVLW  09
0C44:  MOVWF  xBC
0C46:  MOVLW  10
0C48:  MOVWF  xBD
0C4A:  MOVLW  20
0C4C:  MOVWF  xBE
0C4E:  MOVLW  40
0C50:  MOVWF  xBF
0C52:  MOVLW  C0
0C54:  MOVWF  xC0
0C56:  CLRF   xC1
0C58:  CLRF   xC2
0C5A:  CLRF   xC3
0C5C:  CLRF   xC4
0C5E:  CLRF   xC5
0C60:  CLRF   xC6
0C62:  CLRF   xC7
0C64:  CLRF   xC8
0C66:  CLRF   xC9
0C68:  CLRF   xCA
0C6A:  CLRF   xCB
0C6C:  CLRF   xCC
0C6E:  MOVLW  0F
0C70:  MOVWF  xCD
0C72:  MOVLW  3F
0C74:  MOVWF  xCE
0C76:  MOVLW  7F
0C78:  MOVWF  xCF
0C7A:  MOVLW  FF
0C7C:  MOVWF  xD0
0C7E:  MOVLW  F8
0C80:  MOVWF  xD1
0C82:  MOVLW  E0
0C84:  MOVWF  xD2
0C86:  MOVLW  C0
0C88:  MOVWF  xD3
0C8A:  MOVWF  xD4
0C8C:  MOVLW  CE
0C8E:  MOVWF  xD5
0C90:  MOVWF  xD6
0C92:  MOVLW  EE
0C94:  MOVWF  xD7
0C96:  MOVLW  FE
0C98:  MOVWF  xD8
0C9A:  MOVWF  xD9
0C9C:  MOVWF  xDA
0C9E:  MOVLW  7E
0CA0:  MOVWF  xDB
0CA2:  CLRF   xDC
0CA4:  CLRF   xDD
0CA6:  MOVLW  CF
0CA8:  MOVWF  xDE
0CAA:  MOVWF  xDF
0CAC:  MOVLW  9D
0CAE:  MOVWF  xE0
0CB0:  MOVWF  xE1
0CB2:  MOVLW  99
0CB4:  MOVWF  xE2
0CB6:  MOVLW  FB
0CB8:  MOVWF  xE3
0CBA:  MOVLW  F3
0CBC:  MOVWF  xE4
0CBE:  CLRF   xE5
0CC0:  CLRF   xE6
0CC2:  MOVLW  FF
0CC4:  MOVWF  xE7
0CC6:  MOVWF  xE8
0CC8:  MOVLW  0F
0CCA:  MOVWF  xE9
0CCC:  MOVLW  7F
0CCE:  MOVWF  xEA
0CD0:  MOVLW  F8
0CD2:  MOVWF  xEB
0CD4:  MOVLW  F0
0CD6:  MOVWF  xEC
0CD8:  MOVLW  7F
0CDA:  MOVWF  xED
0CDC:  MOVLW  0F
0CDE:  MOVWF  xEE
0CE0:  MOVLW  FF
0CE2:  MOVWF  xEF
0CE4:  MOVWF  xF0
0CE6:  CLRF   xF1
0CE8:  CLRF   xF2
0CEA:  CLRF   xF3
0CEC:  CLRF   xF4
0CEE:  CLRF   xF5
0CF0:  CLRF   xF6
0CF2:  CLRF   xF7
0CF4:  CLRF   xF8
0CF6:  CLRF   xF9
0CF8:  MOVLW  04
0CFA:  MOVWF  xFA
0CFC:  MOVLW  02
0CFE:  MOVWF  xFB
0D00:  MOVLW  01
0D02:  MOVWF  xFC
0D04:  CLRF   xFD
0D06:  CLRF   xFE
0D08:  CLRF   xFF
0D0A:  MOVLB  1
0D0C:  CLRF   x00
0D0E:  CLRF   x01
0D10:  CLRF   x02
0D12:  CLRF   x03
0D14:  CLRF   x04
0D16:  CLRF   x05
0D18:  CLRF   x06
0D1A:  CLRF   x07
0D1C:  CLRF   x08
0D1E:  CLRF   x09
0D20:  CLRF   x0A
0D22:  CLRF   x0B
0D24:  MOVLW  09
0D26:  MOVWF  x0C
0D28:  MOVLW  0D
0D2A:  MOVWF  x0D
0D2C:  MOVLW  16
0D2E:  MOVWF  x0E
0D30:  MOVLW  14
0D32:  MOVWF  x0F
0D34:  MOVLW  20
0D36:  MOVWF  x10
0D38:  MOVLW  40
0D3A:  MOVWF  x11
0D3C:  MOVLW  43
0D3E:  MOVWF  x12
0D40:  MOVLW  85
0D42:  MOVWF  x13
0D44:  MOVLW  88
0D46:  MOVWF  x14
0D48:  MOVLW  30
0D4A:  MOVWF  x15
0D4C:  MOVLW  40
0D4E:  MOVWF  x16
0D50:  MOVLW  80
0D52:  MOVWF  x17
0D54:  CLRF   x18
0D56:  CLRF   x19
0D58:  CLRF   x1A
0D5A:  CLRF   x1B
0D5C:  CLRF   x1C
0D5E:  CLRF   x1D
0D60:  CLRF   x1E
0D62:  CLRF   x1F
0D64:  CLRF   x20
0D66:  CLRF   x21
0D68:  CLRF   x22
0D6A:  CLRF   x23
0D6C:  CLRF   x24
0D6E:  MOVLW  01
0D70:  MOVWF  x25
0D72:  MOVWF  x26
0D74:  MOVWF  x27
0D76:  MOVWF  x28
0D78:  MOVWF  x29
0D7A:  MOVWF  x2A
0D7C:  MOVWF  x2B
0D7E:  CLRF   x2C
0D80:  CLRF   x2D
0D82:  CLRF   x2E
0D84:  CLRF   x2F
0D86:  CLRF   x30
0D88:  MOVLW  E0
0D8A:  MOVWF  x31
0D8C:  MOVWF  x32
0D8E:  MOVLW  E1
0D90:  MOVWF  x33
0D92:  MOVLW  81
0D94:  MOVWF  x34
0D96:  MOVLW  01
0D98:  MOVWF  x35
0D9A:  MOVWF  x36
0D9C:  MOVLW  81
0D9E:  MOVWF  x37
0DA0:  MOVLW  E0
0DA2:  MOVWF  x38
0DA4:  MOVWF  x39
0DA6:  MOVWF  x3A
0DA8:  MOVLW  01
0DAA:  MOVWF  x3B
0DAC:  MOVWF  x3C
0DAE:  MOVLW  E0
0DB0:  MOVWF  x3D
0DB2:  MOVWF  x3E
0DB4:  MOVLW  E1
0DB6:  MOVWF  x3F
0DB8:  MOVLW  61
0DBA:  MOVWF  x40
0DBC:  MOVLW  60
0DBE:  MOVWF  x41
0DC0:  MOVWF  x42
0DC2:  MOVLW  61
0DC4:  MOVWF  x43
0DC6:  MOVLW  01
0DC8:  MOVWF  x44
0DCA:  MOVLW  20
0DCC:  MOVWF  x45
0DCE:  MOVLW  E0
0DD0:  MOVWF  x46
0DD2:  MOVWF  x47
0DD4:  MOVLW  C0
0DD6:  MOVWF  x48
0DD8:  CLRF   x49
0DDA:  MOVWF  x4A
0DDC:  MOVLW  E0
0DDE:  MOVWF  x4B
0DE0:  MOVWF  x4C
0DE2:  MOVLW  20
0DE4:  MOVWF  x4D
0DE6:  CLRF   x4E
0DE8:  CLRF   x4F
0DEA:  MOVLW  E0
0DEC:  MOVWF  x50
0DEE:  MOVWF  x51
0DF0:  MOVWF  x52
0DF2:  CLRF   x53
0DF4:  CLRF   x54
0DF6:  MOVLW  80
0DF8:  MOVWF  x55
0DFA:  MOVLW  C0
0DFC:  MOVWF  x56
0DFE:  MOVLW  E0
0E00:  MOVWF  x57
0E02:  MOVLW  60
0E04:  MOVWF  x58
0E06:  MOVWF  x59
0E08:  MOVLW  E0
0E0A:  MOVWF  x5A
0E0C:  MOVLW  C0
0E0E:  MOVWF  x5B
0E10:  MOVLW  80
0E12:  MOVWF  x5C
0E14:  CLRF   x5D
0E16:  CLRF   x5E
0E18:  MOVWF  x5F
0E1A:  MOVLW  C0
0E1C:  MOVWF  x60
0E1E:  MOVLW  E0
0E20:  MOVWF  x61
0E22:  MOVWF  x62
0E24:  MOVLW  60
0E26:  MOVWF  x63
0E28:  MOVLW  E0
0E2A:  MOVWF  x64
0E2C:  MOVWF  x65
0E2E:  MOVLW  C0
0E30:  MOVWF  x66
0E32:  MOVLW  80
0E34:  MOVWF  x67
0E36:  CLRF   x68
0E38:  MOVLW  01
0E3A:  MOVWF  x69
0E3C:  MOVLW  02
0E3E:  MOVWF  x6A
0E40:  MOVWF  x6B
0E42:  MOVLW  07
0E44:  MOVWF  x6C
0E46:  MOVLW  04
0E48:  MOVWF  x6D
0E4A:  MOVLW  08
0E4C:  MOVWF  x6E
0E4E:  CLRF   x6F
0E50:  CLRF   x70
0E52:  CLRF   x71
0E54:  CLRF   x72
0E56:  CLRF   x73
0E58:  CLRF   x74
0E5A:  CLRF   x75
0E5C:  CLRF   x76
0E5E:  CLRF   x77
0E60:  CLRF   x78
0E62:  CLRF   x79
0E64:  CLRF   x7A
0E66:  CLRF   x7B
0E68:  CLRF   x7C
0E6A:  CLRF   x7D
0E6C:  CLRF   x7E
0E6E:  CLRF   x7F
0E70:  CLRF   x80
0E72:  CLRF   x81
0E74:  CLRF   x82
0E76:  CLRF   x83
0E78:  CLRF   x84
0E7A:  MOVLW  7F
0E7C:  MOVWF  x85
0E7E:  MOVWF  x86
0E80:  MOVLW  01
0E82:  MOVWF  x87
0E84:  MOVLW  0F
0E86:  MOVWF  x88
0E88:  MOVLW  7C
0E8A:  MOVWF  x89
0E8C:  MOVWF  x8A
0E8E:  MOVLW  0F
0E90:  MOVWF  x8B
0E92:  MOVLW  01
0E94:  MOVWF  x8C
0E96:  MOVLW  7F
0E98:  MOVWF  x8D
0E9A:  MOVWF  x8E
0E9C:  CLRF   x8F
0E9E:  CLRF   x90
0EA0:  MOVWF  x91
0EA2:  MOVWF  x92
0EA4:  MOVWF  x93
0EA6:  MOVLW  66
0EA8:  MOVWF  x94
0EAA:  MOVWF  x95
0EAC:  MOVWF  x96
0EAE:  MOVWF  x97
0EB0:  CLRF   x98
0EB2:  MOVLW  40
0EB4:  MOVWF  x99
0EB6:  MOVLW  70
0EB8:  MOVWF  x9A
0EBA:  MOVLW  7D
0EBC:  MOVWF  x9B
0EBE:  MOVLW  3F
0EC0:  MOVWF  x9C
0EC2:  MOVLW  0F
0EC4:  MOVWF  x9D
0EC6:  MOVLW  3F
0EC8:  MOVWF  x9E
0ECA:  MOVLW  7D
0ECC:  MOVWF  x9F
0ECE:  MOVLW  70
0ED0:  MOVWF  xA0
0ED2:  MOVLW  40
0ED4:  MOVWF  xA1
0ED6:  CLRF   xA2
0ED8:  CLRF   xA3
0EDA:  MOVLW  7F
0EDC:  MOVWF  xA4
0EDE:  MOVWF  xA5
0EE0:  MOVWF  xA6
0EE2:  CLRF   xA7
0EE4:  CLRF   xA8
0EE6:  MOVLW  1F
0EE8:  MOVWF  xA9
0EEA:  MOVLW  3F
0EEC:  MOVWF  xAA
0EEE:  MOVLW  7F
0EF0:  MOVWF  xAB
0EF2:  MOVLW  60
0EF4:  MOVWF  xAC
0EF6:  MOVWF  xAD
0EF8:  MOVLW  78
0EFA:  MOVWF  xAE
0EFC:  MOVLW  38
0EFE:  MOVWF  xAF
0F00:  MOVLW  10
0F02:  MOVWF  xB0
0F04:  CLRF   xB1
0F06:  CLRF   xB2
0F08:  MOVLW  1F
0F0A:  MOVWF  xB3
0F0C:  MOVLW  3F
0F0E:  MOVWF  xB4
0F10:  MOVLW  7F
0F12:  MOVWF  xB5
0F14:  MOVLW  70
0F16:  MOVWF  xB6
0F18:  MOVLW  60
0F1A:  MOVWF  xB7
0F1C:  MOVLW  70
0F1E:  MOVWF  xB8
0F20:  MOVLW  7F
0F22:  MOVWF  xB9
0F24:  MOVLW  3F
0F26:  MOVWF  xBA
0F28:  MOVLW  1F
0F2A:  MOVWF  xBB
0F2C:  CLRF   xBC
0F2E:  CLRF   xBD
0F30:  CLRF   xBE
0F32:  CLRF   xBF
0F34:  CLRF   xC0
0F36:  CLRF   xC1
0F38:  CLRF   xC2
0F3A:  CLRF   xC3
0F3C:  CLRF   xC4
0F3E:  CLRF   xC5
0F40:  CLRF   xC6
0F42:  CLRF   xC7
0F44:  CLRF   xC8
0F46:  CLRF   xC9
0F48:  CLRF   xCA
0F4A:  CLRF   xCB
0F4C:  CLRF   xCC
0F4E:  CLRF   xCD
0F50:  CLRF   xCE
0F52:  CLRF   xCF
0F54:  CLRF   xD0
0F56:  CLRF   xD1
0F58:  CLRF   xD2
0F5A:  CLRF   xD3
0F5C:  CLRF   xD4
0F5E:  CLRF   xD5
0F60:  CLRF   xD6
0F62:  CLRF   xD7
0F64:  CLRF   xD8
0F66:  CLRF   xD9
0F68:  CLRF   xDA
0F6A:  CLRF   xDB
0F6C:  CLRF   xDC
0F6E:  CLRF   xDD
0F70:  CLRF   xDE
0F72:  CLRF   xDF
0F74:  CLRF   xE0
0F76:  CLRF   xE1
0F78:  CLRF   xE2
0F7A:  CLRF   xE3
0F7C:  CLRF   xE4
0F7E:  CLRF   xE5
0F80:  CLRF   xE6
0F82:  CLRF   xE7
0F84:  CLRF   xE8
0F86:  CLRF   xE9
0F88:  CLRF   xEA
0F8A:  CLRF   xEB
0F8C:  CLRF   xEC
0F8E:  CLRF   xED
0F90:  CLRF   xEE
0F92:  CLRF   xEF
0F94:  CLRF   xF0
0F96:  CLRF   xF1
0F98:  CLRF   xF2
0F9A:  CLRF   xF3
0F9C:  CLRF   xF4
0F9E:  CLRF   xF5
0FA0:  CLRF   xF6
0FA2:  CLRF   xF7
0FA4:  CLRF   xF8
0FA6:  CLRF   xF9
0FA8:  CLRF   xFA
0FAA:  CLRF   xFB
0FAC:  CLRF   xFC
0FAE:  CLRF   xFD
0FB0:  CLRF   xFE
0FB2:  CLRF   xFF
0FB4:  MOVLB  2
0FB6:  CLRF   x00
0FB8:  CLRF   x01
0FBA:  CLRF   x02
0FBC:  CLRF   x03
0FBE:  CLRF   x04
0FC0:  CLRF   x05
0FC2:  CLRF   x06
0FC4:  CLRF   x07
0FC6:  CLRF   x08
0FC8:  CLRF   x09
0FCA:  CLRF   x0A
0FCC:  CLRF   x0B
0FCE:  CLRF   x0C
0FD0:  CLRF   x0D
0FD2:  CLRF   x0E
0FD4:  CLRF   x0F
0FD6:  CLRF   x10
0FD8:  CLRF   x11
0FDA:  CLRF   x12
0FDC:  CLRF   x13
0FDE:  CLRF   x14
0FE0:  CLRF   x15
0FE2:  CLRF   x16
0FE4:  CLRF   x17
0FE6:  CLRF   x18
0FE8:  CLRF   x19
0FEA:  CLRF   x1A
0FEC:  CLRF   x1B
0FEE:  CLRF   x1C
0FF0:  CLRF   x1D
0FF2:  CLRF   x1E
0FF4:  CLRF   x1F
0FF6:  CLRF   x20
0FF8:  CLRF   x21
0FFA:  CLRF   x22
0FFC:  CLRF   x23
0FFE:  CLRF   x24
1000:  CLRF   x25
1002:  CLRF   x26
1004:  CLRF   x27
1006:  CLRF   x28
1008:  CLRF   x29
100A:  CLRF   x2A
100C:  CLRF   x2B
100E:  CLRF   x2C
1010:  CLRF   x2D
1012:  CLRF   x2E
1014:  CLRF   x2F
1016:  CLRF   x30
1018:  CLRF   x31
101A:  CLRF   x32
101C:  CLRF   x33
101E:  CLRF   x34
1020:  CLRF   x35
1022:  CLRF   x36
1024:  CLRF   x37
1026:  CLRF   x38
1028:  CLRF   x39
102A:  CLRF   x3A
102C:  CLRF   x3B
102E:  CLRF   x3C
1030:  CLRF   x3D
1032:  CLRF   x3E
1034:  CLRF   x3F
1036:  CLRF   x40
1038:  CLRF   x41
103A:  CLRF   x42
103C:  CLRF   x43
103E:  CLRF   x44
1040:  CLRF   x45
1042:  CLRF   x46
1044:  CLRF   x47
1046:  CLRF   x48
1048:  CLRF   x49
104A:  CLRF   x4A
104C:  CLRF   x4B
104E:  CLRF   x4C
1050:  CLRF   x4D
1052:  CLRF   x4E
1054:  CLRF   x4F
1056:  CLRF   x50
1058:  CLRF   x51
105A:  CLRF   x52
105C:  CLRF   x53
105E:  CLRF   x54
1060:  CLRF   x55
1062:  CLRF   x56
1064:  CLRF   x57
1066:  CLRF   x58
1068:  CLRF   x59
106A:  CLRF   x5A
106C:  CLRF   x5B
106E:  CLRF   x5C
1070:  CLRF   x5D
1072:  CLRF   x5E
1074:  CLRF   x5F
1076:  CLRF   x60
1078:  CLRF   x61
107A:  CLRF   x62
107C:  CLRF   x63
107E:  CLRF   x64
1080:  CLRF   x65
1082:  CLRF   x66
1084:  CLRF   x67
1086:  CLRF   x68
1088:  CLRF   x69
108A:  CLRF   x6A
108C:  CLRF   x6B
108E:  CLRF   x6C
1090:  CLRF   x6D
1092:  CLRF   x6E
.................... 	setup_oscillator(OSC_INTRC | OSC_8MHZ);	 
1094:  MOVLW  72
1096:  MOVWF  FD3
1098:  MOVF   FD3,W
.................... 	TRISB=0x00; 
109A:  CLRF   F93
.................... 	PCD_begin(40,0x04); 
109C:  MOVLW  28
109E:  MOVWF  x71
10A0:  MOVLW  04
10A2:  MOVWF  x72
10A4:  MOVLB  0
10A6:  GOTO   0764
.................... 	PCD_setContrast(40); 
10AA:  MOVLW  28
10AC:  MOVLB  2
10AE:  MOVWF  x71
10B0:  MOVLB  0
10B2:  GOTO   07BE
.................... 	PCD_display(); 
10B6:  CALL   0810
.................... 	delay_ms(300); 
10BA:  MOVLW  02
10BC:  MOVLB  2
10BE:  MOVWF  x71
10C0:  MOVLW  96
10C2:  MOVWF  x73
10C4:  MOVLB  0
10C6:  CALL   06FC
10CA:  MOVLB  2
10CC:  DECFSZ x71,F
10CE:  BRA    10C0
.................... 	PCD_clearDisplay(); 
10D0:  MOVLB  0
10D2:  CALL   08C0
.................... 	PCD_display(); 
10D6:  CALL   0810
.................... 	delay_ms(5000); 
10DA:  MOVLW  14
10DC:  MOVLB  2
10DE:  MOVWF  x71
10E0:  MOVLW  FA
10E2:  MOVWF  x73
10E4:  MOVLB  0
10E6:  CALL   06FC
10EA:  MOVLB  2
10EC:  DECFSZ x71,F
10EE:  BRA    10E0
.................... 	set_tris_c(0x10); 
10F0:  MOVLW  10
10F2:  MOVWF  F94
.................... 	output_low(PIN_C0); 
10F4:  BCF    F94.0
10F6:  BCF    F8B.0
.................... 	while(TRUE) 
.................... 	{	 
.................... 		 
.................... 		//printf("%s",InputBuffer); 
.................... 		PCD_clearDisplay(); 
10F8:  MOVLB  0
10FA:  CALL   08C0
.................... 		PCD_setCursor(0,0); 
10FE:  MOVLB  2
1100:  CLRF   x72
1102:  CLRF   x71
1104:  CLRF   x74
1106:  CLRF   x73
1108:  MOVLB  0
110A:  CALL   08EE
.................... 		printf(PCD_drawChart,"%s",InputBuffer); 
110E:  MOVLW  02
1110:  MOVWF  FEA
1112:  MOVLW  1A
1114:  MOVWF  FE9
1116:  BRA    0A02
.................... 		//printf(PCD_drawChart,"MENU:"); 
.................... 		PCD_setCursor(0,8); 
1118:  MOVLB  2
111A:  CLRF   x72
111C:  CLRF   x71
111E:  CLRF   x74
1120:  MOVLW  08
1122:  MOVWF  x73
1124:  MOVLB  0
1126:  CALL   08EE
.................... 		if(option==0)printf(PCD_drawChart,"DISABLED");		 
112A:  MOVLB  2
112C:  MOVF   x6F,F
112E:  BNZ   113E
1130:  MOVLW  E0
1132:  MOVWF  FF6
1134:  MOVLW  06
1136:  MOVWF  FF7
1138:  MOVLB  0
113A:  RCALL  0A28
113C:  MOVLB  2
.................... 		//printf(PCD_drawChart,"Option 1"); 
.................... 		//PCD_setCursor(0,16); 
.................... 		if(option==1)printf(PCD_drawChart,"ENABLED"); 
113E:  DECFSZ x6F,W
1140:  BRA    1150
1142:  MOVLW  EA
1144:  MOVWF  FF6
1146:  MOVLW  06
1148:  MOVWF  FF7
114A:  MOVLB  0
114C:  RCALL  0A28
114E:  MOVLB  2
.................... 		//printf(PCD_drawChart,"Option 2"); 
.................... 		//PCD_setCursor(0,24); 
.................... 		//if(option==2)printf(PCD_drawChart,">"); 
.................... 		//printf(PCD_drawChart,"Option 3"); 
.................... 		printf("buffer:%s",InputBuffer); 
1150:  MOVLW  F2
1152:  MOVWF  FF6
1154:  MOVLW  06
1156:  MOVWF  FF7
1158:  MOVLW  07
115A:  MOVWF  x71
115C:  MOVLB  0
115E:  BRA    0A48
1160:  MOVLW  02
1162:  MOVWF  FEA
1164:  MOVLW  1A
1166:  MOVWF  FE9
1168:  CLRF   16
116A:  BTFSC  FF2.7
116C:  BSF    16.7
116E:  BCF    FF2.7
1170:  CALL   05EC
1174:  BTFSC  16.7
1176:  BSF    FF2.7
.................... 		disable_interrupts(INT_RDA); 
1178:  BCF    F9D.5
.................... 		disable_interrupts(GLOBAL);  
117A:  BCF    FF2.6
117C:  BCF    FF2.7
117E:  BTFSC  FF2.7
1180:  BRA    117C
.................... 		PCD_display(); 
1182:  CALL   0810
.................... 		enable_interrupts(INT_RDA); 
1186:  BSF    F9D.5
.................... 	    enable_interrupts(GLOBAL);  
1188:  MOVLW  C0
118A:  IORWF  FF2,F
.................... 		//option++; 
.................... 		//if(option==3) option=0; 
.................... 		delay_ms(1000); 
118C:  MOVLW  04
118E:  MOVLB  2
1190:  MOVWF  x71
1192:  MOVLW  FA
1194:  MOVWF  x73
1196:  MOVLB  0
1198:  CALL   06FC
119C:  MOVLB  2
119E:  DECFSZ x71,F
11A0:  BRA    1192
.................... 		if(option==1)  
11A2:  DECFSZ x6F,W
11A4:  BRA    11D6
.................... 			{output_high(PIN_C0);delay_ms(2000);option=0;output_low(PIN_C0);PCD_setCursor(0,8);} 
11A6:  BCF    F94.0
11A8:  BSF    F8B.0
11AA:  MOVLW  08
11AC:  MOVWF  x71
11AE:  MOVLW  FA
11B0:  MOVWF  x73
11B2:  MOVLB  0
11B4:  CALL   06FC
11B8:  MOVLB  2
11BA:  DECFSZ x71,F
11BC:  BRA    11AE
11BE:  CLRF   x6F
11C0:  BCF    F94.0
11C2:  BCF    F8B.0
11C4:  CLRF   x72
11C6:  CLRF   x71
11C8:  CLRF   x74
11CA:  MOVLW  08
11CC:  MOVWF  x73
11CE:  MOVLB  0
11D0:  CALL   08EE
11D4:  MOVLB  2
.................... 		for(i=0;i<=20;i++) 
11D6:  CLRF   x70
11D8:  MOVF   x70,W
11DA:  SUBLW  14
11DC:  BNC   1226
.................... 		{ 
.................... 			if(InputBuffer[i]=='1' && InputBuffer[i+1]=='6' && InputBuffer[i+2]=='5') option=1; 
11DE:  CLRF   03
11E0:  MOVF   x70,W
11E2:  ADDLW  1A
11E4:  MOVWF  FE9
11E6:  MOVLW  02
11E8:  ADDWFC 03,W
11EA:  MOVWF  FEA
11EC:  MOVF   FEF,W
11EE:  SUBLW  31
11F0:  BNZ   1222
11F2:  MOVLW  01
11F4:  ADDWF  x70,W
11F6:  CLRF   03
11F8:  ADDLW  1A
11FA:  MOVWF  FE9
11FC:  MOVLW  02
11FE:  ADDWFC 03,W
1200:  MOVWF  FEA
1202:  MOVF   FEF,W
1204:  SUBLW  36
1206:  BNZ   1222
1208:  MOVLW  02
120A:  ADDWF  x70,W
120C:  CLRF   03
120E:  ADDLW  1A
1210:  MOVWF  FE9
1212:  MOVLW  02
1214:  ADDWFC 03,W
1216:  MOVWF  FEA
1218:  MOVF   FEF,W
121A:  SUBLW  35
121C:  BNZ   1222
121E:  MOVLW  01
1220:  MOVWF  x6F
.................... 		} 
1222:  INCF   x70,F
1224:  BRA    11D8
.................... 		 
.................... 	} 
1226:  BRA    10F8
.................... } 
....................  
1228:  SLEEP 

Configuration Fuses:
   Word  1: C820   INTRC_IO IESO FCMEN PLL1 CPUDIV1 USBDIV
   Word  2: 1E38   NOBROWNOUT NOWDT BORV20 PUT WDT32768 VREGEN
   Word  3: 0700   PBADEN CCP2C1 NOMCLR LPT1OSC
   Word  4: 0081   STVREN NODEBUG NOLVP NOXINST
   Word  5: C00F   NOPROTECT NOCPD NOCPB
   Word  6: E00F   NOWRT NOWRTD NOWRTC NOWRTB
   Word  7: 400F   NOEBTR NOEBTRB
